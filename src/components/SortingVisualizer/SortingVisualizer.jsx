// SortingVisualizer.jsx
//
// Author: Adam Paunovic
// Date: 2024-10-20
//
// Description: This component serves as the main sorting visualizer for the application. 
//              It manages the state of the array being sorted, controls the animation 
//              of sorting steps, and updates the display based on the sorting algorithm 
//              selected by the user. It also integrates the visual representation of the 
//              array with the corresponding colors to illustrate sorting actions.
// 
// Key Features:
// - Manages the array state and visual updates during sorting.
// - Handles animation for sorting steps using requestAnimationFrame for smooth transitions.
// - Allows for dynamic adjustments of sorting speed based on user input.
// - Displays the array through the ArrayDisplay component 
//
// Props:
// - array: The initial array to be sorted.
// - speed: The speed factor for the sorting animation.
// - sortSteps: An array of animations generated by the sorting algorithm.
// - isSorting: A boolean indicating whether sorting is in progress.
// - onSortingComplete: A callback function to handle actions after sorting is finished.
// - isSortingComplete: A boolean indicating if sorting has completed.

import React, { useState, useEffect, useCallback, useRef } from "react";
import ArrayDisplay from "../ArrayDisplay/ArrayDisplay";
import InfoSection from "../InfoSection/InfoSection";
import './SortingVisualizer.css';

const SortingVisualizer = ({ array, speed, sortSteps, isSorting, onSortingComplete, isSortingComplete }) => {
    const [barColors, setBarColors] = useState([]); 
    const [currentArray, setCurrentArray] = useState(array);  // Maintain current array state
    const sortingRef = useRef(isSorting);

    // Calculate the base speed for sorting animation based on the array size.
    // The speed is determined through linear interpolation between a minimum 
    // and maximum speed defined for an array size range (20 to 150).
    // Returns the calculated base speed.
    const getBaseSpeed = () => {
        // Minimum baseSpeed for min array size (20)
        const minBaseSpeed = 4; 
        // Maximum baseSpeed for max array size (150)
        const maxBaseSpeed = 25; 
    
        // Linear interpolation
        return minBaseSpeed + (maxBaseSpeed - minBaseSpeed) * ((array.length - 20) / (150 - 20));
    };
    
    // Calculate the speed factor for the sorting animation based on the user-defined speed.
    // This factor adjusts the base speed determined by the size of the array 
    // and the selected speed setting (1 to 5). 
    // Returns the computed speed factor for animation timing.
    const getSpeedFactor = () => {
        const baseSpeed = getBaseSpeed(array.length);
        const speedFactor = baseSpeed / (5 * (6 - speed));
        return speedFactor;
    };

    const speedFactor = getSpeedFactor();  // determines the animation speed

    // This effect updates the `sortingRef` to reflect the current value 
    // of `isSorting`. 
    useEffect(() => {
        sortingRef.current = isSorting; 
    }, [isSorting]);

    // Animate the sorting steps using requestAnimationFrame.
    // This function processes each step in the sorting algorithm, updating 
    // the state of the array and the bar colors based on the actions defined 
    // in the sorting steps. It handles various actions like swap, insert, 
    // highlight, and revert, allowing for smooth animations.
    // The animation speed is adjusted based on the speed factor calculated.
    const animateSorting = useCallback((steps) => {
        let i = 0;
        let lastFrameTime = performance.now();
        let delay = 1000 / (speedFactor * 10)
        const decayFactor = 0.995;

        function animateStep(timestamp) {
            // If all steps are done or sorting stopped, complete sorting
            if (i >= steps.length || !sortingRef.current) {
                onSortingComplete();  
                return;
            }

            // Calculate the time elapsed since the last frame
            const elapsedTime = timestamp - lastFrameTime;


            // Only proceed if enough time has passed
            if (elapsedTime < delay) { 
                requestAnimationFrame(animateStep); // Request the next frame
                return;
            }

            lastFrameTime = timestamp; // Update the last frame time

            delay *= decayFactor;  // Decrease delay gradually

            for (let j = 0; j < speedFactor && i < steps.length; j++) {
                const [barOneIdx, barTwoIdx, action, colors] = steps[i];
                
                // Update bar colors based on action
                setBarColors((prevBarColors) => {
                    const newBarColors = [...prevBarColors];
                    
                     
                    switch (action) {
                        case "revert":
                            // Revert bar colors to default color
                            newBarColors[barOneIdx] = "lawngreen";
                            newBarColors[barTwoIdx] = "lawngreen";
                            break;
                        case "final":
                            // Mark bars as final (sorted)
                            newBarColors[barOneIdx] = "green";
                            if (barTwoIdx !== -1) {
                                newBarColors[barTwoIdx] = "lawngreen";  // Reverts barTwoIdx for smoother animation
                            }
                            break;
                        case "highlight":
                            // Highlight bars for specific action (Ex. As a key for insertion sort)
                            newBarColors[barOneIdx] = colors[0];
                            if (barTwoIdx !== -1) {
                                newBarColors[barTwoIdx] = colors[1];
                            }
                            break;
                        case "highlightRange":
                            // Highlights a range of bars with two colors for each half
                            const mid = Math.floor((barOneIdx + barTwoIdx) / 2);
                            newBarColors.fill(colors[0], barOneIdx, mid + 1);
                            newBarColors.fill(colors[1], mid + 1, barTwoIdx + 1);
                            // Set pivot for animating QuickSort
                            if (colors.length === 3) {
                                newBarColors[barTwoIdx] = colors[2];
                            }
                            break;
                        case "revertRange":
                            // Reverts the color of a range of bars
                            newBarColors.fill("lawngreen", barOneIdx, barTwoIdx + 1);
                            // Set index as final if passed in colors array
                            if (colors.length === 1) {
                                const pivotIdx = colors[0];
                                newBarColors[pivotIdx] = "green";
                            }
                            break;
                        case "swap":
                            // Swap the colors of the bars
                            let temp = newBarColors[barOneIdx];
                            newBarColors[barOneIdx] = newBarColors[barTwoIdx];
                            newBarColors[barTwoIdx] = temp;
                            break;
                        case "insert":
                            // Insert color at barOneIdx into barTwoIdx position
                            newBarColors.splice(barTwoIdx, 0, newBarColors.splice(barOneIdx, 1)[0]);
                            newBarColors[barTwoIdx] = colors[0];
                            // Marks next bar after barOneIdx if 3 colors are passed
                            if (colors.length === 2) {
                                newBarColors[barOneIdx + 1] = colors[1];
                            }
                            break;
                        default:
                            break;
                    }
                    return newBarColors;
                });

                // Handle swap actions
                if (action === "swap") {
                    setCurrentArray((prevArray) => {
                        const newArray = [...prevArray];
                        // Swap the elements in the array
                        const temp = newArray[barOneIdx];
                        newArray[barOneIdx] = newArray[barTwoIdx];
                        newArray[barTwoIdx] = temp;
                        return newArray;  // Return new array state for re-render
                    });
                } 
                // Handle shift actions
                else if (action === "shift") {
                    setCurrentArray((prevArray) => {
                        const newArray = [...prevArray];
                        // Shift barOneIdx bar to barTwoIdx position
                        newArray[barTwoIdx] = newArray[barOneIdx];
                        return newArray;  // Return the new array state for re-render
                    });
                }
                // Handle insert actions
                else if (action === "insert") {
                    setCurrentArray((prevArray) => {
                        const newArray = [...prevArray];
                        // Insert barOneIdx bar into barTwoIdx position
                        newArray.splice(barTwoIdx, 0, newArray.splice(barOneIdx, 1)[0]);
                        return newArray;  // Return the new array state for re-render
                    });
                }

                i++;  // Move to the next step
            }
            
            if (sortingRef.current) {
                requestAnimationFrame(animateStep);  
            }

        }
        if (sortingRef.current) {
            requestAnimationFrame(animateStep);  
        }
    }, [onSortingComplete, speedFactor]);

    // Trigger the animation when sorting starts.
    // This effect checks if sorting is in progress and if there are any 
    // sorting steps available. If both conditions are met, it calls the 
    // animateSorting function with the sorting steps to begin the animation.
    useEffect(() => {
        if (isSorting && sortSteps.length > 0) {
            animateSorting(sortSteps);
        }
    }, [isSorting, sortSteps, animateSorting]);

    // Initialize bar colors when the array changes.
    // This effect resets the current array to the new array passed in as 
    // a prop. It also sets the bar colors based on whether sorting is 
    // complete: if sorting is complete, all bars are colored green; 
    // otherwise, they are colored lawngreen to indicate they are unsorted.
    useEffect(() => {
        setCurrentArray(array);
        // Initialize the bar colors based on whether sorting is complete
        if (isSortingComplete) {
            setBarColors(Array(array.length).fill('green'));
        } else {
            setBarColors(Array(array.length).fill('lawngreen'));
        }
    }, [array, isSortingComplete]);

    return (
        <div className="sorting-visualizer">
            <div className="info-section-1">
                <InfoSection />
            </div>
            <div className="array-container">
                <ArrayDisplay array={currentArray} barColors={barColors} />
            </div>
            <div className="info-section-2">
                <InfoSection />
            </div>
        </div>
    );
};

export default SortingVisualizer;
